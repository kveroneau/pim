# SimsDB Web Database

This web application has zero relations to the project in the parent directory, and they are mutually incompatible with one another.  Why?  Because when I wrote the project in the parent folder, it was early on in my journey with *ObjectPascal*, and it has some far from great practices in it's code base, especially if I am wanting to eventually build a web export for it, it was going in the entirely wrong direction.

In the last week I recently figured out in *Lazarus* and by proxy in *FreePascal* how simple setting up a database program is.  I did glance at the database documentation in the past, but I was just so stubborn as I just came from the *Python world of thinking*, and still many concepts in a compiled language like *ObjectPascal* still eluded me, but I have grown a lot since then.  I expected the same database experience in *ObjectPascal* that I was familiar with in say *Django*, and was trying to either find a direct replacement for that, or at worst, trying to roll my own...  When switching over to a new technology, you cannot expect anything to be the same, this is more so the case when going from an *interpreted language* to a *compiled language*.  When someone tells you that all you need to master is a single language, then picking up a new language and only needing to really know the *syntax* differences is full of *bullshit*, or they've only say went from *.NET* to *Python* or *Ruby*.  While *ObjectPascal* does share a lot with *.NET*, even the creator of those languages are the same.  It's true, look up the creator of *Delphi* and where he went onto.  He then went onto creating the *.NET* language.  Anyways...  *.NET* is still in this case for all intensive purposes a language which runs within a special runtime, and is not *native code*, which is what I am referring to here when I say *interpreted*, as although *.NET* is *technically* compiled, it's engine is still needing to *interpret* those generated bytecodes inside a *Virtual Machine*, similar to Java.  And when you move to a *natively compiled language* from one which is run inside a *virtual environment* can really catch you off-guard.  Now, instead of some runtime engine checking your code at runtime, this is now mostly handled by the developer, and to a lesser extend the *Pascal* or *C* runtime libraries which have their own checks and protections in place during runtime, but they can also be entirely turned off, leaving absolutely every check up to the developer.  These checks cannot be turned off in non-native languages, as the runtime is always there, ever so watching your code run to ensure it doesn't do anything.  At this point, the *operating system* will obviously have it's check in place, such as memory and I/O access, so with native code and all checks off, you are then as a developer at the mercy of the *operating system*.  From experience, the *C Runtime* has a lot less checks in place than the *Pascal Runtime*.  While it is fully possible to get a **Segmentation Fault* in *Pascal*, you need to be trying to purposely do it in most cases, like trying to reference a *null-pointer*.  However, with *ObjectPascal* being very object-oriented and actually resembling typical *Python classes* with similar classes in *ObjectPascal* like `TThread` and `TProcess` which are almost identical to the classes offered in *Python*, in fact, I doubt it would be too difficult to port, or create a program say called `py2pas` which could convert *Python* syntax over *Pascal*, which could be a rather interesting project in itself.  Anyways, my point here is that *ObjectPascal* as native language is really great, and does feel similar to *Python* in some ways, but since it is *statically typed*, most of the things you'll need to learn, even if going to *C* from a *dynamically typed* language is *type conversion* which is automatically handled in most interpreted languages as the *runtime* can easily detect those during runtime and handle them as needed.  If you try to do incorrect assignment in *C* or *Pascal*, well, all hell could be let lose!  *Type conversion* in a *compiled language* needs the understanding of that type by the developer, and potentially it's internal structure in memory.  It is very common in both *C* and *Pascal* to have more than 1 `struct` represent the same place in memory.  In super low-level programming for example, you could have several `structs` to take care of various numeral formats, but all can be located in the same memory address.  This allows those variables in the code to be optimally accessed, whereas in a language with a runtime, without the feature of pointers, this cannot be easily achieved.

I feel that this readme document has now taken on a new life of it's own, but I think I wrote a lot of interesting stuff and points, so I will leave it there or any passer-byer to see.
